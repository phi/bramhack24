import { Component, Input } from "@angular/core";
import { BaseAngular } from "../base-angular";
import * as i0 from "@angular/core";
import * as i1 from "../survey-string.component";
import * as i2 from "./matrixrequiredheader.component";
import * as i3 from "./matrix-row.component";
import * as i4 from "./matrixdropdowncell.component";
import * as i5 from "@angular/common";
import * as i6 from "../utils/dynamic.directive";
export class MatrixTableComponent extends BaseAngular {
    getModel() {
        return this.table;
    }
    trackCellBy(_, cell) {
        return cell.id;
    }
    trackRowBy(index, row) {
        return row.id;
    }
}
MatrixTableComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: MatrixTableComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
MatrixTableComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: MatrixTableComponent, selector: "sv-ng-matrix-table", inputs: { question: "question", table: "table" }, usesInheritance: true, ngImport: i0, template: "<div [style]=\"{ overflowX: question.showHorizontalScroll ? 'scroll' : '' }\" #contentElement\n  [class]=\"question.cssClasses.tableWrapper\">\n  <table [class]=\"question.getTableCss()\">\n    <thead *ngIf=\"table.showHeader\">\n      <tr>\n        <ng-container *ngFor=\"let cell of table.headerRow.cells; trackBy: trackCellBy\">\n          <th *ngIf=\"cell.hasTitle\" [class]=\"cell.className\" [style]=\"{ minWidth: cell.minWidth, width: cell.width }\">\n            <ng-template\n              [component]=\"{ name: question.getColumnHeaderWrapperComponentName($any(cell)), data: { componentData: question.getColumnHeaderWrapperComponentData($any(cell)) } }\">\n              <sv-ng-string [model]=\"cell.locTitle\"></sv-ng-string>\n              <sv-ng-matrixheaderrequired *ngIf=\"!!cell.column\" [column]=\"cell.column\" [question]=\"question\">\n              </sv-ng-matrixheaderrequired>\n            </ng-template>\n          </th>\n\n          <td *ngIf=\"!cell.hasTitle\" [class]=\"cell.className\" [style]=\"{ minWidth: cell.minWidth, width: cell.width }\">\n          </td>\n        </ng-container>\n      </tr>\n    </thead>\n    <tbody>\n      <ng-container *ngFor=\"let row of table.renderedRows; trackBy: trackRowBy\">\n        <sv-ng-matrix-row [model]=\"row\" [question]=\"question\"></sv-ng-matrix-row>\n      </ng-container>\n    </tbody>\n    <tfoot *ngIf=\"table.showFooter\">\n      <tr>\n        <sv-ng-matrixdropdown-cell [cell]=\"cell\" [question]=\"question\"\n          *ngFor=\"let cell of table.footerRow.cells; trackBy: trackCellBy\">\n        </sv-ng-matrixdropdown-cell>\n      </tr>\n    </tfoot>\n  </table>\n</div>", components: [{ type: i1.SurveyStringComponent, selector: "sv-ng-string, '[sv-ng-string]'", inputs: ["model"] }, { type: i2.MatrixRequiredHeader, selector: "sv-ng-matrixheaderrequired", inputs: ["column", "question"] }, { type: i3.MatrixRowComponent, selector: "sv-ng-matrix-row", inputs: ["model", "question"] }, { type: i4.MatrixDropdownCellComponent, selector: "sv-ng-matrixdropdown-cell", inputs: ["question", "cell"] }], directives: [{ type: i5.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i5.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i6.DynamicComponentDirective, selector: "[component]", inputs: ["component"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: MatrixTableComponent, decorators: [{
            type: Component,
            args: [{
                    selector: "sv-ng-matrix-table",
                    templateUrl: "./matrixtable.component.html"
                }]
        }], propDecorators: { question: [{
                type: Input
            }], table: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0cml4dGFibGUuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3F1ZXN0aW9ucy9tYXRyaXh0YWJsZS5jb21wb25lbnQudHMiLCIuLi8uLi8uLi9zcmMvcXVlc3Rpb25zL21hdHJpeHRhYmxlLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2pELE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQzs7Ozs7Ozs7QUFPOUMsTUFBTSxPQUFPLG9CQUFxQixTQUFRLFdBQWdEO0lBRzlFLFFBQVE7UUFDaEIsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDO0lBQ3BCLENBQUM7SUFDTSxXQUFXLENBQUMsQ0FBUyxFQUFFLElBQVM7UUFDckMsT0FBTyxJQUFJLENBQUMsRUFBRSxDQUFDO0lBQ2pCLENBQUM7SUFDTSxVQUFVLENBQUMsS0FBYSxFQUFFLEdBQVE7UUFDdkMsT0FBTyxHQUFHLENBQUMsRUFBRSxDQUFDO0lBQ2hCLENBQUM7O2tIQVhVLG9CQUFvQjtzR0FBcEIsb0JBQW9CLG1JQ1JqQyx3bkRBaUNNOzRGRHpCTyxvQkFBb0I7a0JBSmhDLFNBQVM7bUJBQUM7b0JBQ1QsUUFBUSxFQUFFLG9CQUFvQjtvQkFDOUIsV0FBVyxFQUFFLDhCQUE4QjtpQkFDNUM7OEJBRVUsUUFBUTtzQkFBaEIsS0FBSztnQkFDRyxLQUFLO3NCQUFiLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0IH0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7IEJhc2VBbmd1bGFyIH0gZnJvbSBcIi4uL2Jhc2UtYW5ndWxhclwiO1xuaW1wb3J0IHsgUXVlc3Rpb25NYXRyaXhEcm9wZG93bk1vZGVsQmFzZSwgUXVlc3Rpb25NYXRyaXhEcm9wZG93blJlbmRlcmVkVGFibGUgfSBmcm9tIFwic3VydmV5LWNvcmVcIjtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiBcInN2LW5nLW1hdHJpeC10YWJsZVwiLFxuICB0ZW1wbGF0ZVVybDogXCIuL21hdHJpeHRhYmxlLmNvbXBvbmVudC5odG1sXCJcbn0pXG5leHBvcnQgY2xhc3MgTWF0cml4VGFibGVDb21wb25lbnQgZXh0ZW5kcyBCYXNlQW5ndWxhcjxRdWVzdGlvbk1hdHJpeERyb3Bkb3duUmVuZGVyZWRUYWJsZT4ge1xuICBASW5wdXQoKSBxdWVzdGlvbiE6IFF1ZXN0aW9uTWF0cml4RHJvcGRvd25Nb2RlbEJhc2U7XG4gIEBJbnB1dCgpIHRhYmxlITogUXVlc3Rpb25NYXRyaXhEcm9wZG93blJlbmRlcmVkVGFibGU7XG4gIHByb3RlY3RlZCBnZXRNb2RlbCgpOiBRdWVzdGlvbk1hdHJpeERyb3Bkb3duUmVuZGVyZWRUYWJsZSB7XG4gICAgcmV0dXJuIHRoaXMudGFibGU7XG4gIH1cbiAgcHVibGljIHRyYWNrQ2VsbEJ5KF86IG51bWJlciwgY2VsbDogYW55KTogc3RyaW5nIHtcbiAgICByZXR1cm4gY2VsbC5pZDtcbiAgfVxuICBwdWJsaWMgdHJhY2tSb3dCeShpbmRleDogbnVtYmVyLCByb3c6IGFueSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHJvdy5pZDtcbiAgfVxufVxuIiwiPGRpdiBbc3R5bGVdPVwieyBvdmVyZmxvd1g6IHF1ZXN0aW9uLnNob3dIb3Jpem9udGFsU2Nyb2xsID8gJ3Njcm9sbCcgOiAnJyB9XCIgI2NvbnRlbnRFbGVtZW50XG4gIFtjbGFzc109XCJxdWVzdGlvbi5jc3NDbGFzc2VzLnRhYmxlV3JhcHBlclwiPlxuICA8dGFibGUgW2NsYXNzXT1cInF1ZXN0aW9uLmdldFRhYmxlQ3NzKClcIj5cbiAgICA8dGhlYWQgKm5nSWY9XCJ0YWJsZS5zaG93SGVhZGVyXCI+XG4gICAgICA8dHI+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGNlbGwgb2YgdGFibGUuaGVhZGVyUm93LmNlbGxzOyB0cmFja0J5OiB0cmFja0NlbGxCeVwiPlxuICAgICAgICAgIDx0aCAqbmdJZj1cImNlbGwuaGFzVGl0bGVcIiBbY2xhc3NdPVwiY2VsbC5jbGFzc05hbWVcIiBbc3R5bGVdPVwieyBtaW5XaWR0aDogY2VsbC5taW5XaWR0aCwgd2lkdGg6IGNlbGwud2lkdGggfVwiPlxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlXG4gICAgICAgICAgICAgIFtjb21wb25lbnRdPVwieyBuYW1lOiBxdWVzdGlvbi5nZXRDb2x1bW5IZWFkZXJXcmFwcGVyQ29tcG9uZW50TmFtZSgkYW55KGNlbGwpKSwgZGF0YTogeyBjb21wb25lbnREYXRhOiBxdWVzdGlvbi5nZXRDb2x1bW5IZWFkZXJXcmFwcGVyQ29tcG9uZW50RGF0YSgkYW55KGNlbGwpKSB9IH1cIj5cbiAgICAgICAgICAgICAgPHN2LW5nLXN0cmluZyBbbW9kZWxdPVwiY2VsbC5sb2NUaXRsZVwiPjwvc3Ytbmctc3RyaW5nPlxuICAgICAgICAgICAgICA8c3YtbmctbWF0cml4aGVhZGVycmVxdWlyZWQgKm5nSWY9XCIhIWNlbGwuY29sdW1uXCIgW2NvbHVtbl09XCJjZWxsLmNvbHVtblwiIFtxdWVzdGlvbl09XCJxdWVzdGlvblwiPlxuICAgICAgICAgICAgICA8L3N2LW5nLW1hdHJpeGhlYWRlcnJlcXVpcmVkPlxuICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICA8L3RoPlxuXG4gICAgICAgICAgPHRkICpuZ0lmPVwiIWNlbGwuaGFzVGl0bGVcIiBbY2xhc3NdPVwiY2VsbC5jbGFzc05hbWVcIiBbc3R5bGVdPVwieyBtaW5XaWR0aDogY2VsbC5taW5XaWR0aCwgd2lkdGg6IGNlbGwud2lkdGggfVwiPlxuICAgICAgICAgIDwvdGQ+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgPC90cj5cbiAgICA8L3RoZWFkPlxuICAgIDx0Ym9keT5cbiAgICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IHJvdyBvZiB0YWJsZS5yZW5kZXJlZFJvd3M7IHRyYWNrQnk6IHRyYWNrUm93QnlcIj5cbiAgICAgICAgPHN2LW5nLW1hdHJpeC1yb3cgW21vZGVsXT1cInJvd1wiIFtxdWVzdGlvbl09XCJxdWVzdGlvblwiPjwvc3YtbmctbWF0cml4LXJvdz5cbiAgICAgIDwvbmctY29udGFpbmVyPlxuICAgIDwvdGJvZHk+XG4gICAgPHRmb290ICpuZ0lmPVwidGFibGUuc2hvd0Zvb3RlclwiPlxuICAgICAgPHRyPlxuICAgICAgICA8c3YtbmctbWF0cml4ZHJvcGRvd24tY2VsbCBbY2VsbF09XCJjZWxsXCIgW3F1ZXN0aW9uXT1cInF1ZXN0aW9uXCJcbiAgICAgICAgICAqbmdGb3I9XCJsZXQgY2VsbCBvZiB0YWJsZS5mb290ZXJSb3cuY2VsbHM7IHRyYWNrQnk6IHRyYWNrQ2VsbEJ5XCI+XG4gICAgICAgIDwvc3YtbmctbWF0cml4ZHJvcGRvd24tY2VsbD5cbiAgICAgIDwvdHI+XG4gICAgPC90Zm9vdD5cbiAgPC90YWJsZT5cbjwvZGl2PiJdfQ==