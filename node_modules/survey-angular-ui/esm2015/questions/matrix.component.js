import { Component } from "@angular/core";
import { QuestionAngular } from "../question";
import { AngularComponentFactory } from "../component-factory";
import * as i0 from "@angular/core";
import * as i1 from "../survey-string.component";
import * as i2 from "@angular/common";
import * as i3 from "../utils/dynamic.directive";
export class MatrixQuestionComponent extends QuestionAngular {
    ngOnInit() {
        this.model.visibleRowsChangedCallback = () => {
            this.detectChanges();
        };
        super.ngOnInit();
    }
    onCellChanged(row, column) {
        row.value = column.value;
        this.detectChanges();
    }
    trackRowByFn(i, row) {
        return "column-" + row.name + "-" + i;
    }
    trackColumnByFn(i, column) {
        return "column-" + column.value + "-" + i;
    }
}
MatrixQuestionComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: MatrixQuestionComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
MatrixQuestionComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: MatrixQuestionComponent, selector: "sv-ng-matrix-question", usesInheritance: true, ngImport: i0, template: "<ng-template #template>\n  <div [class]=\"model.cssClasses.tableWrapper\" #contentElement>\n    <fieldset>\n      <legend class=\"sv-hidden\">{{model.locTitle.renderedHtml}}</legend>\n      <table [class]=\"model.getTableCss()\">\n        <thead *ngIf=\"model.showHeader\">\n          <tr>\n            <td *ngIf=\"model.hasRows\"></td>\n            <th\n              *ngFor=\"let column of model.visibleColumns\" [style]=\"{ minWidth: model.columnMinWidth, width: model.columnMinWidth }\" [class]=\"model.cssClasses.headerCell\">\n              <ng-template [component]=\"{ name: model.getColumnHeaderWrapperComponentName(column), data: { componentData: model.getColumnHeaderWrapperComponentData(column) } }\">\n                <sv-ng-string [model]=\"column.locText\"></sv-ng-string>\n              </ng-template>\n            </th>\n          </tr>\n        </thead>\n        <tbody>\n          <tr *ngFor=\"let row of model.visibleRows; trackBy: trackRowByFn \" [class]=\"row.rowClasses || undefined\">\n           <td [class]=\"row.rowTextClasses\" [style]=\"{ minWidth: model.rowTitleWidth, width: model.rowTitleWidth }\" *ngIf=\"model.hasRows\">\n              <ng-template [component]=\"{ name: model.getRowHeaderWrapperComponentName($any(row)), data: { componentData: model.getRowHeaderWrapperComponentData($any(row)) } }\">\n                <sv-ng-string [model]=\"row.locText\"></sv-ng-string>\n              </ng-template>\n            </td>\n            <ng-container *ngIf=\"model.hasCellText\">\n              <td *ngFor=\"let column of model.visibleColumns\"\n                [class]=\"model.getItemClass(row, column)\"\n                (click)=\"onCellChanged(row, column)\" [model]=\"model.getCellDisplayLocText(row.name, column)\" sv-ng-string>\n              </td>\n            </ng-container>\n            <ng-container *ngIf=\"!model.hasCellText\">\n              <td\n              *ngFor=\"let column of model.visibleColumns; index as columnIndex; trackBy: trackColumnByFn\"\n              [attr.data-responsive-title]=\"column.locText.renderedHtml\"\n              [class]=\"model.cssClasses.cell\">\n                <ng-template [component]=\"{ name: model.cellComponent, data: { cellChangedOwner: this, question: model, row: row, column: column, columnIndex: columnIndex } }\"></ng-template>\n              </td>\n            </ng-container>\n          </tr>\n        </tbody>\n      </table>\n    </fieldset>\n  </div>\n</ng-template>", styles: [":host{display:none}\n"], components: [{ type: i1.SurveyStringComponent, selector: "sv-ng-string, '[sv-ng-string]'", inputs: ["model"] }], directives: [{ type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3.DynamicComponentDirective, selector: "[component]", inputs: ["component"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: MatrixQuestionComponent, decorators: [{
            type: Component,
            args: [{
                    selector: "sv-ng-matrix-question",
                    templateUrl: "./matrix.component.html",
                    styleUrls: ["../hide-host.scss"]
                }]
        }] });
AngularComponentFactory.Instance.registerComponent("matrix-question", MatrixQuestionComponent);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0cml4LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9xdWVzdGlvbnMvbWF0cml4LmNvbXBvbmVudC50cyIsIi4uLy4uLy4uL3NyYy9xdWVzdGlvbnMvbWF0cml4LmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDMUMsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUU5QyxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQzs7Ozs7QUFPL0QsTUFBTSxPQUFPLHVCQUF3QixTQUFRLGVBQW9DO0lBQ3RFLFFBQVE7UUFDZixJQUFJLENBQUMsS0FBSyxDQUFDLDBCQUEwQixHQUFHLEdBQUcsRUFBRTtZQUMzQyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7UUFDdkIsQ0FBQyxDQUFDO1FBQ0YsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQ25CLENBQUM7SUFDTSxhQUFhLENBQUMsR0FBUSxFQUFFLE1BQVc7UUFDeEMsR0FBRyxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDO1FBQ3pCLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztJQUN2QixDQUFDO0lBQ0QsWUFBWSxDQUFDLENBQVMsRUFBRSxHQUFRO1FBQzlCLE9BQU8sU0FBUyxHQUFHLEdBQUcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQztJQUN4QyxDQUFDO0lBQ0QsZUFBZSxDQUFDLENBQVMsRUFBRSxNQUFXO1FBQ3BDLE9BQU8sU0FBUyxHQUFHLE1BQU0sQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQztJQUM1QyxDQUFDOztxSEFoQlUsdUJBQXVCO3lHQUF2Qix1QkFBdUIsb0ZDVnBDLGk2RUEwQ2M7NEZEaENELHVCQUF1QjtrQkFMbkMsU0FBUzttQkFBQztvQkFDVCxRQUFRLEVBQUUsdUJBQXVCO29CQUNqQyxXQUFXLEVBQUUseUJBQXlCO29CQUN0QyxTQUFTLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQztpQkFDakM7O0FBb0JELHVCQUF1QixDQUFDLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxpQkFBaUIsRUFBRSx1QkFBdUIsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7IFF1ZXN0aW9uQW5ndWxhciB9IGZyb20gXCIuLi9xdWVzdGlvblwiO1xuaW1wb3J0IHsgUXVlc3Rpb25NYXRyaXhNb2RlbCB9IGZyb20gXCJzdXJ2ZXktY29yZVwiO1xuaW1wb3J0IHsgQW5ndWxhckNvbXBvbmVudEZhY3RvcnkgfSBmcm9tIFwiLi4vY29tcG9uZW50LWZhY3RvcnlcIjtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiBcInN2LW5nLW1hdHJpeC1xdWVzdGlvblwiLFxuICB0ZW1wbGF0ZVVybDogXCIuL21hdHJpeC5jb21wb25lbnQuaHRtbFwiLFxuICBzdHlsZVVybHM6IFtcIi4uL2hpZGUtaG9zdC5zY3NzXCJdXG59KVxuZXhwb3J0IGNsYXNzIE1hdHJpeFF1ZXN0aW9uQ29tcG9uZW50IGV4dGVuZHMgUXVlc3Rpb25Bbmd1bGFyPFF1ZXN0aW9uTWF0cml4TW9kZWw+IHtcbiAgb3ZlcnJpZGUgbmdPbkluaXQoKSB7XG4gICAgdGhpcy5tb2RlbC52aXNpYmxlUm93c0NoYW5nZWRDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIHRoaXMuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIH07XG4gICAgc3VwZXIubmdPbkluaXQoKTtcbiAgfVxuICBwdWJsaWMgb25DZWxsQ2hhbmdlZChyb3c6IGFueSwgY29sdW1uOiBhbnkpOiB2b2lkIHtcbiAgICByb3cudmFsdWUgPSBjb2x1bW4udmFsdWU7XG4gICAgdGhpcy5kZXRlY3RDaGFuZ2VzKCk7XG4gIH1cbiAgdHJhY2tSb3dCeUZuKGk6IG51bWJlciwgcm93OiBhbnkpOiBzdHJpbmcge1xuICAgIHJldHVybiBcImNvbHVtbi1cIiArIHJvdy5uYW1lICsgXCItXCIgKyBpO1xuICB9XG4gIHRyYWNrQ29sdW1uQnlGbihpOiBudW1iZXIsIGNvbHVtbjogYW55KTogc3RyaW5nIHtcbiAgICByZXR1cm4gXCJjb2x1bW4tXCIgKyBjb2x1bW4udmFsdWUgKyBcIi1cIiArIGk7XG4gIH1cbn1cblxuQW5ndWxhckNvbXBvbmVudEZhY3RvcnkuSW5zdGFuY2UucmVnaXN0ZXJDb21wb25lbnQoXCJtYXRyaXgtcXVlc3Rpb25cIiwgTWF0cml4UXVlc3Rpb25Db21wb25lbnQpOyIsIjxuZy10ZW1wbGF0ZSAjdGVtcGxhdGU+XG4gIDxkaXYgW2NsYXNzXT1cIm1vZGVsLmNzc0NsYXNzZXMudGFibGVXcmFwcGVyXCIgI2NvbnRlbnRFbGVtZW50PlxuICAgIDxmaWVsZHNldD5cbiAgICAgIDxsZWdlbmQgY2xhc3M9XCJzdi1oaWRkZW5cIj57e21vZGVsLmxvY1RpdGxlLnJlbmRlcmVkSHRtbH19PC9sZWdlbmQ+XG4gICAgICA8dGFibGUgW2NsYXNzXT1cIm1vZGVsLmdldFRhYmxlQ3NzKClcIj5cbiAgICAgICAgPHRoZWFkICpuZ0lmPVwibW9kZWwuc2hvd0hlYWRlclwiPlxuICAgICAgICAgIDx0cj5cbiAgICAgICAgICAgIDx0ZCAqbmdJZj1cIm1vZGVsLmhhc1Jvd3NcIj48L3RkPlxuICAgICAgICAgICAgPHRoXG4gICAgICAgICAgICAgICpuZ0Zvcj1cImxldCBjb2x1bW4gb2YgbW9kZWwudmlzaWJsZUNvbHVtbnNcIiBbc3R5bGVdPVwieyBtaW5XaWR0aDogbW9kZWwuY29sdW1uTWluV2lkdGgsIHdpZHRoOiBtb2RlbC5jb2x1bW5NaW5XaWR0aCB9XCIgW2NsYXNzXT1cIm1vZGVsLmNzc0NsYXNzZXMuaGVhZGVyQ2VsbFwiPlxuICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgW2NvbXBvbmVudF09XCJ7IG5hbWU6IG1vZGVsLmdldENvbHVtbkhlYWRlcldyYXBwZXJDb21wb25lbnROYW1lKGNvbHVtbiksIGRhdGE6IHsgY29tcG9uZW50RGF0YTogbW9kZWwuZ2V0Q29sdW1uSGVhZGVyV3JhcHBlckNvbXBvbmVudERhdGEoY29sdW1uKSB9IH1cIj5cbiAgICAgICAgICAgICAgICA8c3Ytbmctc3RyaW5nIFttb2RlbF09XCJjb2x1bW4ubG9jVGV4dFwiPjwvc3Ytbmctc3RyaW5nPlxuICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgPC90aD5cbiAgICAgICAgICA8L3RyPlxuICAgICAgICA8L3RoZWFkPlxuICAgICAgICA8dGJvZHk+XG4gICAgICAgICAgPHRyICpuZ0Zvcj1cImxldCByb3cgb2YgbW9kZWwudmlzaWJsZVJvd3M7IHRyYWNrQnk6IHRyYWNrUm93QnlGbiBcIiBbY2xhc3NdPVwicm93LnJvd0NsYXNzZXMgfHwgdW5kZWZpbmVkXCI+XG4gICAgICAgICAgIDx0ZCBbY2xhc3NdPVwicm93LnJvd1RleHRDbGFzc2VzXCIgW3N0eWxlXT1cInsgbWluV2lkdGg6IG1vZGVsLnJvd1RpdGxlV2lkdGgsIHdpZHRoOiBtb2RlbC5yb3dUaXRsZVdpZHRoIH1cIiAqbmdJZj1cIm1vZGVsLmhhc1Jvd3NcIj5cbiAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtjb21wb25lbnRdPVwieyBuYW1lOiBtb2RlbC5nZXRSb3dIZWFkZXJXcmFwcGVyQ29tcG9uZW50TmFtZSgkYW55KHJvdykpLCBkYXRhOiB7IGNvbXBvbmVudERhdGE6IG1vZGVsLmdldFJvd0hlYWRlcldyYXBwZXJDb21wb25lbnREYXRhKCRhbnkocm93KSkgfSB9XCI+XG4gICAgICAgICAgICAgICAgPHN2LW5nLXN0cmluZyBbbW9kZWxdPVwicm93LmxvY1RleHRcIj48L3N2LW5nLXN0cmluZz5cbiAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwibW9kZWwuaGFzQ2VsbFRleHRcIj5cbiAgICAgICAgICAgICAgPHRkICpuZ0Zvcj1cImxldCBjb2x1bW4gb2YgbW9kZWwudmlzaWJsZUNvbHVtbnNcIlxuICAgICAgICAgICAgICAgIFtjbGFzc109XCJtb2RlbC5nZXRJdGVtQ2xhc3Mocm93LCBjb2x1bW4pXCJcbiAgICAgICAgICAgICAgICAoY2xpY2spPVwib25DZWxsQ2hhbmdlZChyb3csIGNvbHVtbilcIiBbbW9kZWxdPVwibW9kZWwuZ2V0Q2VsbERpc3BsYXlMb2NUZXh0KHJvdy5uYW1lLCBjb2x1bW4pXCIgc3Ytbmctc3RyaW5nPlxuICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiIW1vZGVsLmhhc0NlbGxUZXh0XCI+XG4gICAgICAgICAgICAgIDx0ZFxuICAgICAgICAgICAgICAqbmdGb3I9XCJsZXQgY29sdW1uIG9mIG1vZGVsLnZpc2libGVDb2x1bW5zOyBpbmRleCBhcyBjb2x1bW5JbmRleDsgdHJhY2tCeTogdHJhY2tDb2x1bW5CeUZuXCJcbiAgICAgICAgICAgICAgW2F0dHIuZGF0YS1yZXNwb25zaXZlLXRpdGxlXT1cImNvbHVtbi5sb2NUZXh0LnJlbmRlcmVkSHRtbFwiXG4gICAgICAgICAgICAgIFtjbGFzc109XCJtb2RlbC5jc3NDbGFzc2VzLmNlbGxcIj5cbiAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgW2NvbXBvbmVudF09XCJ7IG5hbWU6IG1vZGVsLmNlbGxDb21wb25lbnQsIGRhdGE6IHsgY2VsbENoYW5nZWRPd25lcjogdGhpcywgcXVlc3Rpb246IG1vZGVsLCByb3c6IHJvdywgY29sdW1uOiBjb2x1bW4sIGNvbHVtbkluZGV4OiBjb2x1bW5JbmRleCB9IH1cIj48L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgPC90cj5cbiAgICAgICAgPC90Ym9keT5cbiAgICAgIDwvdGFibGU+XG4gICAgPC9maWVsZHNldD5cbiAgPC9kaXY+XG48L25nLXRlbXBsYXRlPiJdfQ==