import { Component, ElementRef, Input, ViewChild } from "@angular/core";
import { BaseAngular } from "./base-angular";
import * as i0 from "@angular/core";
import * as i1 from "./element.component";
import * as i2 from "@angular/common";
import * as i3 from "./utils/dynamic.directive";
export class RowComponent extends BaseAngular {
    constructor(cdr, vcr, ngZone) {
        super(cdr, vcr);
        this.ngZone = ngZone;
    }
    getModel() {
        return this.row;
    }
    trackElementBy(index, element) {
        return element.name + index;
    }
    ngAfterViewInit() {
        var _a;
        const el = (_a = this.container) === null || _a === void 0 ? void 0 : _a.nativeElement;
        if (!!el) {
            this.row.setRootElement(el);
            if (!this.row.isNeedRender) {
                this.ngZone.runOutsideAngular(() => {
                    setTimeout(() => {
                        this.row.startLazyRendering(el);
                    }, 10);
                });
            }
        }
    }
    onModelChanged() {
        var _a;
        super.onModelChanged();
        if (!this.previousModel) {
            return;
        }
        else {
            this.previousModel.setRootElement(undefined);
            if ((_a = this.container) === null || _a === void 0 ? void 0 : _a.nativeElement) {
                this.row.setRootElement(this.container.nativeElement);
            }
            this.row.isNeedRender = this.previousModel.isNeedRender;
            this.stopLazyRendering();
        }
    }
    stopLazyRendering() {
        this.row.stopLazyRendering();
        this.row.isNeedRender = !this.row.isLazyRendering();
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        this.row.setRootElement(undefined);
        this.stopLazyRendering();
    }
}
RowComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: RowComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ViewContainerRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
RowComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: RowComponent, selector: "sv-ng-row", inputs: { row: "row" }, viewQueries: [{ propertyName: "container", first: true, predicate: ["container"], descendants: true, read: ElementRef }], usesInheritance: true, ngImport: i0, template: "<ng-template #template>\n  <div [class]=\"row.getRowCss()\" #container>\n    <ng-container *ngFor=\"let element of row.visibleElements; trackBy: trackElementBy\">\n      <sv-ng-element [model]=\"$any(element)\" *ngIf=\"row.isNeedRender\"></sv-ng-element>\n      <ng-template *ngIf=\"!row.isNeedRender && element.skeletonComponentName\" [component]=\"{ name: element.skeletonComponentName, data: { element: element } }\"></ng-template>\n    </ng-container>\n  </div>\n</ng-template>", styles: [":host{display:none}\n"], components: [{ type: i1.ElementComponent, selector: "sv-ng-element", inputs: ["model"] }], directives: [{ type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.DynamicComponentDirective, selector: "[component]", inputs: ["component"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: RowComponent, decorators: [{
            type: Component,
            args: [{
                    selector: "sv-ng-row",
                    templateUrl: "./row.component.html",
                    styleUrls: ["./hide-host.scss"]
                }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i0.ViewContainerRef }, { type: i0.NgZone }]; }, propDecorators: { row: [{
                type: Input
            }], container: [{
                type: ViewChild,
                args: ["container", { read: ElementRef }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm93LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9yb3cuY29tcG9uZW50LnRzIiwiLi4vLi4vc3JjL3Jvdy5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQW9DLFNBQVMsRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFVLFNBQVMsRUFBb0IsTUFBTSxlQUFlLENBQUM7QUFFcEksT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7OztBQU03QyxNQUFNLE9BQU8sWUFBYSxTQUFRLFdBQTZCO0lBRzdELFlBQVksR0FBc0IsRUFBRSxHQUFxQixFQUFVLE1BQWM7UUFDL0UsS0FBSyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztRQURpRCxXQUFNLEdBQU4sTUFBTSxDQUFRO0lBRWpGLENBQUM7SUFFUyxRQUFRO1FBQ2hCLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQztJQUNsQixDQUFDO0lBQ0QsY0FBYyxDQUFFLEtBQWEsRUFBRSxPQUFpQjtRQUM5QyxPQUFPLE9BQU8sQ0FBQyxJQUFJLEdBQUcsS0FBSyxDQUFDO0lBQzlCLENBQUM7SUFDTSxlQUFlOztRQUNwQixNQUFNLEVBQUUsR0FBRyxNQUFBLElBQUksQ0FBQyxTQUFTLDBDQUFFLGFBQWEsQ0FBQztRQUN6QyxJQUFJLENBQUMsQ0FBQyxFQUFFLEVBQUU7WUFDUixJQUFJLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUM1QixJQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxZQUFZLEVBQUU7Z0JBQ3pCLElBQUksQ0FBQyxNQUFNLENBQUMsaUJBQWlCLENBQUMsR0FBRyxFQUFFO29CQUNqQyxVQUFVLENBQUMsR0FBRyxFQUFFO3dCQUNkLElBQUksQ0FBQyxHQUFHLENBQUMsa0JBQWtCLENBQUMsRUFBRSxDQUFDLENBQUM7b0JBQ2xDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztnQkFDVCxDQUFDLENBQUMsQ0FBQzthQUNKO1NBQ0Y7SUFDSCxDQUFDO0lBQ2tCLGNBQWM7O1FBQy9CLEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztRQUN2QixJQUFHLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRTtZQUN0QixPQUFPO1NBQ1I7YUFBTTtZQUNMLElBQUksQ0FBQyxhQUFhLENBQUMsY0FBYyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQzdDLElBQUcsTUFBQSxJQUFJLENBQUMsU0FBUywwQ0FBRSxhQUFhLEVBQUU7Z0JBQ2hDLElBQUksQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsYUFBYSxDQUFDLENBQUM7YUFDdkQ7WUFDRCxJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLFlBQVksQ0FBQztZQUN4RCxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztTQUMxQjtJQUNILENBQUM7SUFDTyxpQkFBaUI7UUFDdkIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBQzdCLElBQUksQ0FBQyxHQUFHLENBQUMsWUFBWSxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxlQUFlLEVBQUUsQ0FBQztJQUN0RCxDQUFDO0lBQ2UsV0FBVztRQUN6QixLQUFLLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDcEIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDbkMsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7SUFDM0IsQ0FBQzs7MEdBL0NVLFlBQVk7OEZBQVosWUFBWSw0SkFFUyxVQUFVLG9EQ1Y1QyxtZUFPYzs0RkRDRCxZQUFZO2tCQUx4QixTQUFTO21CQUFDO29CQUNULFFBQVEsRUFBRSxXQUFXO29CQUNyQixXQUFXLEVBQUUsc0JBQXNCO29CQUNuQyxTQUFTLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQztpQkFDaEM7NEpBRVUsR0FBRztzQkFBWCxLQUFLO2dCQUN3QyxTQUFTO3NCQUF0RCxTQUFTO3VCQUFDLFdBQVcsRUFBRSxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBZnRlclZpZXdJbml0LCBDaGFuZ2VEZXRlY3RvclJlZiwgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBJbnB1dCwgTmdab25lLCBWaWV3Q2hpbGQsIFZpZXdDb250YWluZXJSZWYgfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHsgSUVsZW1lbnQsIFF1ZXN0aW9uUm93TW9kZWwgfSBmcm9tIFwic3VydmV5LWNvcmVcIjtcbmltcG9ydCB7IEJhc2VBbmd1bGFyIH0gZnJvbSBcIi4vYmFzZS1hbmd1bGFyXCI7XG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6IFwic3Ytbmctcm93XCIsXG4gIHRlbXBsYXRlVXJsOiBcIi4vcm93LmNvbXBvbmVudC5odG1sXCIsXG4gIHN0eWxlVXJsczogW1wiLi9oaWRlLWhvc3Quc2Nzc1wiXVxufSlcbmV4cG9ydCBjbGFzcyBSb3dDb21wb25lbnQgZXh0ZW5kcyBCYXNlQW5ndWxhcjxRdWVzdGlvblJvd01vZGVsPiBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQge1xuICBASW5wdXQoKSByb3chOiBRdWVzdGlvblJvd01vZGVsO1xuICBAVmlld0NoaWxkKFwiY29udGFpbmVyXCIsIHsgcmVhZDogRWxlbWVudFJlZiB9KSBjb250YWluZXI/OiBFbGVtZW50UmVmPEhUTUxEaXZFbGVtZW50PjtcbiAgY29uc3RydWN0b3IoY2RyOiBDaGFuZ2VEZXRlY3RvclJlZiwgdmNyOiBWaWV3Q29udGFpbmVyUmVmLCBwcml2YXRlIG5nWm9uZTogTmdab25lKSB7XG4gICAgc3VwZXIoY2RyLCB2Y3IpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldE1vZGVsKCk6IFF1ZXN0aW9uUm93TW9kZWwge1xuICAgIHJldHVybiB0aGlzLnJvdztcbiAgfVxuICB0cmFja0VsZW1lbnRCeSAoaW5kZXg6IG51bWJlciwgZWxlbWVudDogSUVsZW1lbnQpOiBzdHJpbmcge1xuICAgIHJldHVybiBlbGVtZW50Lm5hbWUgKyBpbmRleDtcbiAgfVxuICBwdWJsaWMgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgIGNvbnN0IGVsID0gdGhpcy5jb250YWluZXI/Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKCEhZWwpIHtcbiAgICAgIHRoaXMucm93LnNldFJvb3RFbGVtZW50KGVsKTtcbiAgICAgIGlmKCF0aGlzLnJvdy5pc05lZWRSZW5kZXIpIHtcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yb3cuc3RhcnRMYXp5UmVuZGVyaW5nKGVsKTtcbiAgICAgICAgICB9LCAxMCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwcm90ZWN0ZWQgb3ZlcnJpZGUgb25Nb2RlbENoYW5nZWQoKTogdm9pZCB7XG4gICAgc3VwZXIub25Nb2RlbENoYW5nZWQoKTtcbiAgICBpZighdGhpcy5wcmV2aW91c01vZGVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHJldmlvdXNNb2RlbC5zZXRSb290RWxlbWVudCh1bmRlZmluZWQpO1xuICAgICAgaWYodGhpcy5jb250YWluZXI/Lm5hdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5yb3cuc2V0Um9vdEVsZW1lbnQodGhpcy5jb250YWluZXIubmF0aXZlRWxlbWVudCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJvdy5pc05lZWRSZW5kZXIgPSB0aGlzLnByZXZpb3VzTW9kZWwuaXNOZWVkUmVuZGVyO1xuICAgICAgdGhpcy5zdG9wTGF6eVJlbmRlcmluZygpO1xuICAgIH1cbiAgfVxuICBwcml2YXRlIHN0b3BMYXp5UmVuZGVyaW5nKCkge1xuICAgIHRoaXMucm93LnN0b3BMYXp5UmVuZGVyaW5nKCk7XG4gICAgdGhpcy5yb3cuaXNOZWVkUmVuZGVyID0gIXRoaXMucm93LmlzTGF6eVJlbmRlcmluZygpO1xuICB9XG4gIHB1YmxpYyBvdmVycmlkZSBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICBzdXBlci5uZ09uRGVzdHJveSgpO1xuICAgIHRoaXMucm93LnNldFJvb3RFbGVtZW50KHVuZGVmaW5lZCk7XG4gICAgdGhpcy5zdG9wTGF6eVJlbmRlcmluZygpO1xuICB9XG59IiwiPG5nLXRlbXBsYXRlICN0ZW1wbGF0ZT5cbiAgPGRpdiBbY2xhc3NdPVwicm93LmdldFJvd0NzcygpXCIgI2NvbnRhaW5lcj5cbiAgICA8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCBlbGVtZW50IG9mIHJvdy52aXNpYmxlRWxlbWVudHM7IHRyYWNrQnk6IHRyYWNrRWxlbWVudEJ5XCI+XG4gICAgICA8c3YtbmctZWxlbWVudCBbbW9kZWxdPVwiJGFueShlbGVtZW50KVwiICpuZ0lmPVwicm93LmlzTmVlZFJlbmRlclwiPjwvc3YtbmctZWxlbWVudD5cbiAgICAgIDxuZy10ZW1wbGF0ZSAqbmdJZj1cIiFyb3cuaXNOZWVkUmVuZGVyICYmIGVsZW1lbnQuc2tlbGV0b25Db21wb25lbnROYW1lXCIgW2NvbXBvbmVudF09XCJ7IG5hbWU6IGVsZW1lbnQuc2tlbGV0b25Db21wb25lbnROYW1lLCBkYXRhOiB7IGVsZW1lbnQ6IGVsZW1lbnQgfSB9XCI+PC9uZy10ZW1wbGF0ZT5cbiAgICA8L25nLWNvbnRhaW5lcj5cbiAgPC9kaXY+XG48L25nLXRlbXBsYXRlPiJdfQ==